#include <sys/ptrace.h>
#include <stdio.h>
#include<string.h>
#include <signal.h>
#include <stdlib.h>
#include <unistd.h>

// char *realtable="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz9876543210+/";
// char *table1="XYZABCDEFGHIJKLMNOPQRSTUVWxyzabcdefghijklmnopqrstuvw0132465789+/";
// char *table2="GHIJKLMNOPQRSTUVWXYZABCDEFghijklmnopqrstuvwxyzabcdef0213456879+/";
char realtable[65]={0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0xd8,0xab,0x0,0x8c,0xbc,0xd3,0xa,0xf7,0xe4,0x58,0x5,0xb8,0xb3,0x45,0x6,0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0xf,0x2,0xc1,0xaf,0xbd,0x5b,0x76,0xb2,0x24,0xd9,0x28,0x66,0xa1,0x2e,0x8,0xb,0x4e};
char table1[65]={0x89,0xc5,0x29,0x5a,0xcd,0x78,0xfe,0xc0,0xdb,0x9a,0x20,0x79,0xd2,0xc6,0x4b,0x3e,0x56,0xfc,0x1b,0xbe,0x18,0xaa,0xe,0x62,0xb7,0x6f,0xea,0xdc,0x67,0xdf,0x75,0x1c,0xe8,0x37,0xf9,0xe2,0x85,0x35,0xad,0xe7,0x22,0x74,0xac,0x96,0x73,0xe6,0xb4,0xf0,0xce,0xcf,0xf2,0x97,0x5f,0xec,0x27,0x80,0x59,0x12,0x10,0xb1,0x31,0xc7,0x19,0x60};
char table2[65]={0x9a,0x20,0x79,0xd2,0xc6,0x4b,0x3e,0x56,0xfc,0x1b,0xbe,0x18,0xaa,0xe,0x62,0xb7,0x6f,0x89,0xc5,0x29,0x5a,0xcd,0x78,0xfe,0xc0,0xdb,0xe2,0x85,0x35,0xad,0xe7,0x22,0x74,0xac,0x96,0x73,0xe6,0xb4,0xf0,0xce,0xcf,0xf2,0x97,0xea,0xdc,0x67,0xdf,0x75,0x1c,0xe8,0x37,0xf9,0x5f,0x80,0xec,0x27,0x59,0x10,0x12,0x31,0xb1,0xc7,0x19,0x60};


int teakey[4]={123,321,456,654};
char S[256] = { 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
	0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
	0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
	0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
	0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
	0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
	0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
	0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
	0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
	0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
	0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
	0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
	0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
	0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
	0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
	0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
void teaencrypt(int* EntryData, int* Key)
{
    //分别加密数组中的前四个字节与后4个字节,4个字节为一组每次加密两组
    unsigned int x = EntryData[0];
    unsigned int y = EntryData[1];
 
    unsigned int sum = 0;
    unsigned int delta = 0x9E3779B9;
    //总共加密32轮
    for (int i = 0; i < 32; i++)
    {
        sum += delta;
        x += ((y << 4) + Key[0]) ^ (y + sum) ^ ((y >> 5) + Key[1]);
        y += ((x << 4) + Key[2]) ^ (x + sum) ^ ((x >> 5) + Key[3]);
    }
    //最后加密的结果重新写入到数组中
    EntryData[0] = x;
    EntryData[1] = y;
}

void alarmHandler(int sig)
{
//    printf("time is up, quicker next time\n");
   exit(1);
}
__attribute__((constructor))void setupSig(void) 
{//设置程序一开始就执行
   signal(SIGALRM, alarmHandler);
   alarm(3);
}
unsigned char *base64_encode(unsigned char *str)  
{  
    long len;  
    long str_len;  
    unsigned char *res;  
    int i,j;  
//定义base64编码表  
    unsigned char *base64_table=realtable;  
  
//计算经过base64编码后的字符串长度  
    str_len=strlen(str);  
    if(str_len % 3 == 0)  
        len=str_len/3*4;  
    else  
        len=(str_len/3+1)*4;  
  
    res=malloc(sizeof(unsigned char)*len+1);  
    res[len]='\0';  
  
//以3个8位字符为一组进行编码  
    for(i=0,j=0;i<len-2;j+=3,i+=4)  
    {  
        res[i]=base64_table[str[j]>>2]; //取出第一个字符的前6位并找出对应的结果字符  
        res[i+1]=base64_table[(str[j]&0x3)<<4 | (str[j+1]>>4)]; //将第一个字符的后位与第二个字符的前4位进行组合并找到对应的结果字符  
        res[i+2]=base64_table[(str[j+1]&0xf)<<2 | (str[j+2]>>6)]; //将第二个字符的后4位与第三个字符的前2位组合并找出对应的结果字符  
        res[i+3]=base64_table[str[j+2]&0x3f]; //取出第三个字符的后6位并找出结果字符  
    }  
  
    switch(str_len % 3)  
    {  
        case 1:  
            res[i-2]='=';  
            res[i-1]='=';  
            break;  
        case 2:  
            res[i-1]='=';  
            break;  
    }  
  
    return res;  
}  
void char2box(unsigned char*table)
{
    for(int i=0;i<strlen(table);i++)
    {
        for (int j = 0;j < 256;j++)
		{
			if (S[j] == table[i])
			{
				table[i] = j;
				break;
			}
		}
    }
}
void box2char(unsigned char*box)
{
    for(int i=0;i<64;i++)
    {
        box[i]=S[box[i]];
    }
}

// char flag[33]="SBCTF{2e_easy_Anti-debug_in_ELF}";
// unsigned int encteaflag[8]={433482296,1838182781,316518698,3985382284,2320459233,601266079,3342405730,1077568203};
// char *encflag="LDoTDU1uhD0npa0PgYrJ7bCiQ4nci9VgVeX6u8qfLhX=";
char boxencflag[45]={0x4b,0xfe,0x96,0xe,0xfe,0x62,0xec,0xcf,0x85,0xfe,0x5f,0xac,0x73,0xdf,0x5f,0x1b,0xe2,0xc5,0xb4,0xd2,0xb1,0x75,0x78,0x35,0xbe,0x59,0xac,0x1c,0x35,0xc7,0xb7,0xe2,0xb7,0x37,0x89,0x12,0xcf,0x31,0xe6,0xf9,0x4b,0x85,0x89,0xa8};

int checkdebug()
{
    if(ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1)
    {
        return 1;
    }
    return 0;
}
// int IsDebugPrecent_continue()
// {
//     if(debugflag==1)
// }
void IsDebugPrecent_exit(int debugflag)
{
    if(debugflag==1)
       {
            printf("bad boy:(\n");
            exit(0);
       }

}
void Debug()
{
    int debugflag=checkdebug();
    if(debugflag==0)//正常
    {
        for(int i=0;i<4;i++)
        {
            teakey[i]^=0x2e;
        }
        for(int i=0;i<256;i++)
        {
            S[i]^=0xff;
        }
        strncpy(realtable,table1,64);
        box2char(realtable);
        printf("good boy :)\n");
    }
    if(debugflag==1)//调试
    {
        for(int i=0;i<4;i++)
        {
            teakey[i]^=0xe2;
        }
        strncpy(realtable,table2,64);
        box2char(realtable);
        printf("bad boy :(\n");
    }

}
int check(char *input)
{
    char *base64enc_flag;
    for(int i=0;i<4;i++)
    {
        teaencrypt((int*)&input[i*8],teakey);
    }

    strncpy(realtable,table1,64);
    box2char(realtable);
    base64enc_flag=base64_encode(input);
    char2box(base64enc_flag);

    if(strcmp(boxencflag,base64enc_flag)==0)
        return 1;
    return 0;
}
int enc(char *input)
{
    Debug();
    return check(input);
}

int main()
{
    printf("I turst you, don't reverse me\n");
    char inputflag[33];
    printf("Please input your flag quickly, and I'll tell you the result:\n");
    scanf("%s",inputflag);
    if(enc(inputflag)==1)
    {
        printf("Right!\n");
        return 0;
    }
    else 
    {
        printf("Wrong!\n");
        return 0;
    }


    return 0;
}